# Задание 10

## Задача 1

### Условие 

Отношение (A, B, C, D, E, G) имеет следующие функциональные зависимости:

* AB → C
* C → A
* BC → D
* ACD → B
* D → EG
* BE → C
* CG → BD
* CE → AG

Постройте закрытие атрибута (Attribute Closure) (BD)+

### Решение

| Добавленные атрибуты  | Функциональная зависимость |
|:------------- |:---------------| 
| { B, D } | Тривиальность |
| { B, D, E, G } | D → EG |
| { B, D, E, G, C } | BE → C |
| { B, D, E, G, C, A } | C → A |

(BD)+ = { A, B, C, D, E, G }

## Задача 2

### Условие 

Посмотрите на отношения: Order (ProductNo, ProductName, CustomerNo, CustomerName, OrderDate, UnitPrice, Quantity, SubTotal, Tax, Total)

Ставка налога зависит от Товара (например, 20 % для книг или 30 % для предметов роскоши).
В день допускается только один заказ на продукт и клиента (несколько заказов объединяются).

А) Определить нетривиальные функциональные зависимости в отношении

Б) Каковы ключи-кандидаты?

### Решение

А) Номер товара определяет имя товара, стоимость единицы данного товара и налог для данного товара:

***ProductNo → ProductName, UnitPrice, Tax***

Номер покупателя определяет имя покупателя: 

***CustomerNo → CustomerName***

По условию мы знаем, что покупатель не может за день приобрести больше одной единицы конкретного товара (продукта),
значит, Quantity определяет, сколько ***различных*** товаров приобрел покупатель в рамках ***одного заказа***.
Один заказ для покупателя будет определяться датой, т.е. если человек за день заказал товары A, B и C, то они все
окажутся в одном заказе из-за того, что их приобрели в один и тот же день.
Значит, номер покупателя и дата будут определять количество различных единиц товара, приобретенных пользователем
в рамках одного заказа.

***ProductNo, CustomerNo, OrderDate → Quantity***

Вообще наличие Quantity, SubTotal и Total в данном отношении мне кажется странным (было бы логичнее вынести их в
отдельную таблицу, поскольку эти данные будут дублироваться в нескольких строчках, если пользователь заказал не один товар),
но имеем, что имеем, так что для расчета промежуточной стоимости нам потребуется Quantity, т.е. количество заказанных товаров,
а также ProductNo и UnitPrice каждого из этих товаров:

***UnitPrice, Quantity → SubTotal***

***SubTotal, Tax → Total***

Мне вновь кажется дотаточно странным то, что мы сначала считаем промежуточную стоимость ***всего*** заказа, потом пересчитываем цену каждого товара
с учетом налога, а потом ***заново*** суммируем получившиеся стоимости для расчета Total (ведь намного проще было бы хранить поля UnitPrice, Tax,
UnitPriceWithTax, потому что тогда можно было бы обойтись без SubTotal и лишнего пересчета). Но с учетом имеющихся полей рассмотренные связи
самые логичные.

Б) (ProductNo)+ = { ProductNo, ProductName, UnitPrice, SubTotal, Total }

(CustomerNo)+ = { CustomerNo, CustomerName }

(OrderDate)+ = { OrderDate, Quantity, SubTotal, Total }

(ProductNo, CustomerNo, OrderDate)+ = { ProductNo, ProductName, CustomerNo, CustomerName, OrderDate, UnitPrice, Quantity, SubTotal, Tax, Total }

Ключ-кандидат единственный — { ProductNo, CustomerNo, OrderDate }, посольку именно данный минимальный набор
атрибутов необходим для уникальной идентификации заказа.

## Задача 3

### Условие 

Рассмотрим соотношение R(A, B, C, D) со следующими функциональными зависимостями: F = { A → D, AB → C, AC → B }

А) *Каковы все ключи-кандидаты?
Б) Преобразуйте R в 3NF, используя алгоритм синтеза.

### Решение

А) A+ = { A, D, C, B }

B+ = { B, C }

C+ = { C, B }

D+ = { D }

Атрибут A в комбинации с любыми другими атрибутами будет являться супер-ключом, поскольку закрытие любой из данных комбинаций
будет включать в себя все атрибуты отношения R. 

Однако поскольку мы ищем ключ-кандидат, закрытие которого должно включать в себя все атрибуты и который при этом должен быть
минимальным, нашим ответом будет атрибут A.

Б) Попробуем составить новые таблицы, исходя из представленных отношений:

{ A, D } (A — ключ; D — атрибут, зависящий от ключа)

{ A, B, C } 

Нет смысла добавлять таблицу { A, C, B }, поскольку таблица с такими атрибутами уже существует.

Поскольку C зависит от атрибута B, который является частью составного ключа, а B зависит от атрибута C, который также является частью составного 
ключа, можно сделать вывод, что атрибуты A, B, C будут являться составным ключом в таблице { A, B, C }. Внутри данного ключа B и C будут зависеть
друг от друга, но это допустимо, поскольку они оба входят в ключ.
